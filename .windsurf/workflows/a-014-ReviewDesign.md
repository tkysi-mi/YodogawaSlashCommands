---
description: 設計ドキュメント間の一貫性をチェックし、要件・ドメインモデルとの整合性を検証するレビューワークフロー
auto_execution_mode: 1
---

# /a-014-ReviewDesign

## 目的

- 設計フェーズで作成されたすべてのドキュメント間の一貫性を体系的にチェックする。
- 設計ドキュメント間の不整合、漏れ、矛盾を検出し、修正提案を提供する。
- 設計が要件定義とドメインモデルを正しく実現しているか検証する。
- 技術選定、アーキテクチャ、データモデル、API仕様の整合性を確認する。
- レビュー結果レポートを作成し、修正すべき項目を優先度付きでリストアップする。

## 前提

- 要件・ドメインレビューが完了していること（`/a-006-ReviewRequirementsDomain` 実施済み）
- 以下の設計ドキュメントが作成されていること：
  - `docs/project/04-design/01-tech-stack.md`
  - `docs/project/04-design/02-repository-structure.md`
  - `docs/project/04-design/03-screen-design.md`
  - `docs/project/04-design/04-data-model.md`
  - `docs/project/04-design/05-api-spec.md`
  - `docs/project/04-design/06-architecture.md`
  - `docs/project/04-design/07-infrastructure.md`
- 要件・ドメインドキュメントが存在すること（整合性チェックのため）

## 手順

### 1. ドキュメント存在確認

- 以下の設計ドキュメントを読み込む：
  - `@docs/project/04-design/01-tech-stack.md`
  - `@docs/project/04-design/02-repository-structure.md`
  - `@docs/project/04-design/03-screen-design.md`
  - `@docs/project/04-design/04-data-model.md`
  - `@docs/project/04-design/05-api-spec.md`
  - `@docs/project/04-design/06-architecture.md`
  - `@docs/project/04-design/07-infrastructure.md`

- 参照用として要件・ドメインドキュメントを読み込む：
  - `@docs/project/01-requirements/03-features-planned.md`
  - `@docs/project/01-requirements/04-non-functional-requirements.md`
  - `@docs/project/03-domain/01-domain-model.md`
  - `@docs/project/03-domain/02-ubiquitous-language.md`

- 不足しているドキュメントがある場合：
  - 「以下のドキュメントが見つかりません：[リスト]」
  - 「先に該当するワークフローを実行してください。」
  - レビューは実行可能な範囲で継続

### 2. レビュー項目の初期化

- レビュー結果を記録するための構造を準備：
  ```
  レビュー結果:
  - OK: 問題なし
  - Warning: 要確認（重大ではないが改善推奨）
  - Error: 修正必須（不整合や重大な漏れ）
  ```

### 3. 一貫性チェック1: テックスタック ↔ アーキテクチャ

#### 3.1. 技術選定の妥当性チェック

- テックスタックで選定された技術を抽出：
  - フロントエンド（フレームワーク、状態管理、UIライブラリ）
  - バックエンド（言語、フレームワーク、ORM）
  - データベース（RDBMS, NoSQL, キャッシュ）
  - インフラ（クラウド、コンテナ、CI/CD）

- アーキテクチャ設計と照合：
  - アーキテクチャ図に記載されたコンポーネントが選定技術と一致するか
  - レイヤー構造が選定フレームワークの規約に従っているか

**チェック項目**:
- [ ] アーキテクチャ図のすべてのコンポーネントに対応する技術が選定されている
- [ ] 選定された技術がアーキテクチャパターン（MVC, Clean Architecture, Hexagonalなど）に適合している
- [ ] アーキテクチャの依存関係が技術スタックで解決可能である

**検出すべき問題**:
- ❌ **Error**: アーキテクチャ図のコンポーネントに対応する技術が選定されていない
- ❌ **Error**: 選定された技術が互いに互換性がない（例: React + Django Templatesなど）
- ⚠️ **Warning**: アーキテクチャパターンと技術選定が最適な組み合わせでない可能性

#### 3.2. ADR（Architecture Decision Records）との整合性

- アーキテクチャドキュメントのADRを確認
- 各技術選定理由がADRに記録されているか確認

**検出すべき問題**:
- ⚠️ **Warning**: 重要な技術選定にADRが存在しない

### 4. 一貫性チェック2: データモデル ↔ ドメインモデル

#### 4.1. エンティティマッピング

- ドメインモデルのAggregatesを抽出
- データモデル（ERD）のテーブル/エンティティと照合

**チェック項目**:
- [ ] すべてのAggregateに対応するテーブル/エンティティが存在する
- [ ] Aggregate Rootがテーブルの主キーとして定義されている
- [ ] Value Objectが適切にモデリングされている（埋め込み or 別テーブル）
- [ ] ドメインモデルの関連（1:1, 1:N, N:M）がERDで正しく表現されている

**検出すべき問題**:
- ❌ **Error**: Aggregateに対応するテーブルが存在しない
- ❌ **Error**: Aggregate間の関連がERDで矛盾している
- ⚠️ **Warning**: Value Objectがテーブルとして定義されている（正規化しすぎの可能性）
- ⚠️ **Warning**: Aggregateの境界を超えた外部キー参照がある（トランザクション境界の問題）

#### 4.2. 用語の一貫性

- ユビキタス言語で定義された用語がテーブル名・カラム名で使用されているか確認

**検出すべき問題**:
- ❌ **Error**: データモデルでドメイン用語以外の用語が使われている
- ⚠️ **Warning**: テーブル名・カラム名がユビキタス言語と表記が異なる（例: User vs. ユーザー）

### 5. 一貫性チェック3: API仕様 ↔ データモデル

#### 5.1. リクエスト/レスポンスとデータモデルの対応

- API仕様のエンドポイント一覧を抽出
- 各エンドポイントのリクエスト/レスポンス構造とデータモデルを照合

**チェック項目**:
- [ ] すべてのAPIレスポンスがデータモデルのエンティティに基づいている
- [ ] APIリクエストのフィールドがデータモデルのカラムと対応している
- [ ] データモデルの必須カラム（NOT NULL）がAPIリクエストでも必須となっている
- [ ] データモデルの制約（一意制約、外部キー制約）がAPIバリデーションで保証されている

**検出すべき問題**:
- ❌ **Error**: APIレスポンスにデータモデルに存在しないフィールドがある
- ❌ **Error**: データモデルの必須カラムがAPIリクエストで任意となっている
- ⚠️ **Warning**: APIレスポンスがデータモデルのすべてのカラムを含んでいる（セキュリティリスク）
- ⚠️ **Warning**: N+1問題が発生する可能性のあるAPI設計

#### 5.2. API認証・認可とデータモデルの対応

- API仕様の認証・認可方式を確認
- ユーザー/ロールに関するテーブルがデータモデルに存在するか確認

**検出すべき問題**:
- ❌ **Error**: API認証に必要なテーブル（users, roles, permissionsなど）がデータモデルに存在しない

### 6. 一貫性チェック4: 画面設計 ↔ API仕様

#### 6.1. 画面とAPIエンドポイントのマッピング

- 画面設計の各画面を抽出
- 各画面で必要なAPIエンドポイントがAPI仕様に定義されているか確認

**チェック項目**:
- [ ] すべての画面に必要なAPIエンドポイント（GET, POST, PUT, DELETEなど）が定義されている
- [ ] 画面遷移に必要なデータ取得APIが存在する
- [ ] フォーム送信に対応するAPIエンドポイントが存在する
- [ ] リアルタイム更新が必要な画面にWebSocket/SSEエンドポイントが定義されている

**検出すべき問題**:
- ❌ **Error**: 画面で必要なAPIエンドポイントが定義されていない
- ❌ **Error**: 画面のフォームフィールドに対応するAPIリクエストパラメータがない
- ⚠️ **Warning**: 画面で使用されないAPIエンドポイントが定義されている（不要なAPI）

#### 6.2. 画面状態とAPIレスポンスの対応

- 画面の各状態（ローディング、エラー、Empty Stateなど）を確認
- APIのレスポンス形式（成功、エラー、空配列など）と照合

**検出すべき問題**:
- ⚠️ **Warning**: APIエラーレスポンスに対応する画面エラー表示が設計されていない
- ⚠️ **Warning**: Empty State（データなし状態）が画面設計で考慮されていない

### 7. 一貫性チェック5: API仕様 ↔ ドメインモデル

#### 7.1. API操作とドメインコマンド/クエリの対応

- API仕様のエンドポイントを操作別に分類：
  - コマンド（POST, PUT, DELETE）: ドメインモデルのCommandsに対応
  - クエリ（GET）: ドメインモデルのRead Modelsに対応

**チェック項目**:
- [ ] すべてのドメインCommandに対応するAPIエンドポイント（POST/PUT/DELETE）が存在する
- [ ] すべてのRead Modelに対応するAPIエンドポイント（GET）が存在する
- [ ] APIエンドポイントのパス構造がAggregate構造を反映している

**検出すべき問題**:
- ❌ **Error**: ドメインCommandに対応するAPIエンドポイントがない
- ⚠️ **Warning**: ドメインモデルで定義されていないCommandに対応するAPIが存在する
- ⚠️ **Warning**: Aggregateの境界を超えた複合APIが存在する（トランザクション問題の可能性）

#### 7.2. APIのビジネスルールとドメインPolicyの対応

- ドメインモデルのPoliciesを抽出
- API仕様のバリデーション・ビジネスルールと照合

**検出すべき問題**:
- ⚠️ **Warning**: ドメインPolicyがAPI仕様のバリデーションに反映されていない

### 8. 一貫性チェック6: リポジトリ構造 ↔ テックスタック

#### 8.1. ディレクトリ構造と技術規約の整合性

- 選定されたフレームワーク・技術の推奨ディレクトリ構造を確認
- リポジトリ構造ドキュメントのディレクトリ構造と比較

**チェック項目**:
- [ ] フレームワークの規約に従ったディレクトリ構造となっている
- [ ] アーキテクチャパターン（Clean Architecture, DDD等）が構造に反映されている
- [ ] フロントエンド・バックエンドの分離方針が明確である

**検出すべき問題**:
- ⚠️ **Warning**: フレームワークの標準的な構造から大きく逸脱している
- ⚠️ **Warning**: アーキテクチャパターンが構造に反映されていない

#### 8.2. モジュール分割とBounded Contextの対応

- ドメインモデルのBounded Contextを抽出
- リポジトリ構造のモジュール/パッケージ分割と照合

**検出すべき問題**:
- ⚠️ **Warning**: Bounded Contextに対応するモジュール/パッケージが存在しない
- ⚠️ **Warning**: 複数のBounded Contextが1つのモジュールに混在している

### 9. 一貫性チェック7: インフラ ↔ アーキテクチャ

#### 9.1. インフラ構成とアーキテクチャの整合性

- アーキテクチャ設計のコンポーネント構成を抽出
- インフラ設計のサーバー構成・ネットワーク構成と照合

**チェック項目**:
- [ ] アーキテクチャの各レイヤー（Presentation, Application, Domain, Infrastructure）に対応するインフラコンポーネントが存在する
- [ ] マイクロサービス/モノリスの選択がインフラ構成に反映されている
- [ ] 通信方式（REST, GraphQL, gRPC, Message Queue等）がインフラで実現可能である

**検出すべき問題**:
- ❌ **Error**: アーキテクチャで定義されたコンポーネントをホストするインフラがない
- ❌ **Error**: アーキテクチャの通信方式がインフラでサポートされていない
- ⚠️ **Warning**: インフラのリソース配分がアーキテクチャ設計と不整合

#### 9.2. 非機能要件とインフラの整合性

- 非機能要件（性能、可用性、スケーラビリティ、セキュリティ）を抽出
- インフラ設計で実現されているか確認

**チェック項目**:
- [ ] 性能要件（レスポンスタイム、スループット）をインフラで達成可能
- [ ] 可用性要件（稼働率、RPO/RTO）がインフラで保証されている
- [ ] スケーラビリティ要件（同時接続数、データ量増加）に対応できる
- [ ] セキュリティ要件（暗号化、アクセス制御、監査ログ）が実装されている

**検出すべき問題**:
- ❌ **Error**: 非機能要件を満たすインフラ構成になっていない
- ⚠️ **Warning**: 非機能要件に対するインフラ余裕度が不足している

### 10. 一貫性チェック8: 設計全体 ↔ 要件・ドメイン

#### 10.1. 機能要件のカバレッジ

- 予定機能一覧（features-planned.md）を抽出
- 各機能について、対応する設計（画面、API、データモデル）が存在するか確認

**チェック項目**:
- [ ] すべての優先度High機能に対応する画面設計が存在する
- [ ] すべての優先度High機能に対応するAPIが存在する
- [ ] すべての優先度High機能に対応するデータモデルが存在する

**検出すべき問題**:
- ❌ **Error**: 優先度Highの機能に対応する設計がない（画面、API、データモデルのいずれか）
- ⚠️ **Warning**: 優先度Mediumの機能に対応する設計がない

#### 10.2. ドメインモデルの実現性

- ドメインモデルのすべてのAggregate、Command、Eventを抽出
- 設計で実現可能か確認：
  - Aggregateがデータモデルで表現されているか
  - CommandがAPIで実行可能か
  - Eventが適切に永続化・通知される設計か

**検出すべき問題**:
- ❌ **Error**: ドメインモデルの重要な概念が設計で実現されていない

### 11. 一貫性チェック9: テックスタック ↔ 非機能要件

#### 11.1. 技術選定と性能要件の整合性

- 非機能要件の性能指標を抽出
- 選定技術で達成可能か確認

**チェック項目**:
- [ ] 選定されたフレームワークで要求される性能を達成できる
- [ ] 選定されたデータベースで要求されるスループットを処理できる
- [ ] 選定された技術でスケーリング要件を満たせる

**検出すべき問題**:
- ❌ **Error**: 選定技術が性能要件を満たせない（ベンチマーク、実績から判断）
- ⚠️ **Warning**: 選定技術で性能要件を満たすためには高度な最適化が必要

#### 11.2. 技術選定とセキュリティ要件の整合性

- セキュリティ要件を抽出
- 選定技術でセキュリティ要件を満たせるか確認

**検出すべき問題**:
- ❌ **Error**: 選定技術がセキュリティ要件（暗号化、認証方式等）をサポートしていない
- ⚠️ **Warning**: 選定技術のセキュリティ脆弱性が報告されている

### 12. レビュー結果レポートの作成

- 検出されたすべての問題をカテゴリ別に整理：

```markdown
# 設計ドキュメント一貫性レビュー結果

**レビュー実施日**: [日付]

## サマリー

- ✅ OK: X項目
- ⚠️ Warning: X項目
- ❌ Error: X項目

## 修正が必要な項目

### 優先度: High（修正必須）

#### 1. [問題のタイトル]
- **カテゴリ**: データモデル ↔ ドメインモデル
- **詳細**: [具体的な問題の説明]
- **影響**: [この問題が放置された場合の影響]
- **修正提案**: [具体的な修正方法]
- **関連ドキュメント**:
  - `docs/project/03-domain/01-domain-model.md`
  - `docs/project/04-design/04-data-model.md`

### 優先度: Medium（改善推奨）

### 優先度: Low（任意）

## チェック項目別の詳細

### 1. テックスタック ↔ アーキテクチャ
- 技術選定妥当性: [評価]
- ADR整合性: [評価]
- 検出された問題: X件

### 2. データモデル ↔ ドメインモデル
- Aggregateカバレッジ: X / Y (XX%)
- 用語一貫性: [評価]
- 検出された問題: X件

### 3. API仕様 ↔ データモデル
- リクエスト/レスポンス整合性: [評価]
- 認証・認可整合性: [評価]
- 検出された問題: X件

### 4. 画面設計 ↔ API仕様
- 画面-APIマッピング: X / Y (XX%)
- 画面状態カバレッジ: [評価]
- 検出された問題: X件

### 5. API仕様 ↔ ドメインモデル
- Command対応率: X / Y (XX%)
- Query対応率: X / Y (XX%)
- 検出された問題: X件

### 6. リポジトリ構造 ↔ テックスタック
- フレームワーク規約準拠: [評価]
- Bounded Context対応: [評価]
- 検出された問題: X件

### 7. インフラ ↔ アーキテクチャ
- インフラ構成整合性: [評価]
- 非機能要件対応: [評価]
- 検出された問題: X件

### 8. 設計全体 ↔ 要件・ドメイン
- 機能要件カバレッジ（High）: X / Y (XX%)
- ドメインモデル実現性: [評価]
- 検出された問題: X件

### 9. テックスタック ↔ 非機能要件
- 性能要件達成可能性: [評価]
- セキュリティ要件対応: [評価]
- 検出された問題: X件

## 次のアクション

1. [最優先で修正すべき項目]
2. [次に修正すべき項目]
3. [余裕があれば修正する項目]

## 設計品質評価

### 総合評価
- **整合性**: [優/良/可/不可]
- **完全性**: [優/良/可/不可]
- **実現可能性**: [優/良/可/不可]
- **保守性**: [優/良/可/不可]

### 所見
[全体的な設計の質、気づいた点、推奨事項など]

## 備考

[追加のコメント、次フェーズへの推奨事項など]
```

### 13. レビュー結果の保存

- レビュー結果を `docs/project/DESIGN-REVIEW-REPORT.md` として保存

- ユーザーに結果を報告：
  - 「設計レビューが完了しました。」
  - Error件数、Warning件数を表示
  - 「詳細は `docs/project/DESIGN-REVIEW-REPORT.md` を参照してください。」

### 14. 修正ガイダンス

- 検出された問題について、修正方法を提案：
  - Errorが検出された場合：「以下の問題を優先的に修正してください：」
  - 修正すべきドキュメントとワークフローを案内：
    - 例：「Aggregateに対応するテーブルがありません → `/a-010-DefineDataModel` でERDを更新」
    - 例：「画面に必要なAPIが定義されていません → `/a-011-DefineAPISpec` でエンドポイントを追加」

- ユーザーに確認：「今すぐ修正作業を開始しますか？それとも後で個別に修正しますか？」

## 完了条件

- すべてのチェック項目が実行されている
- 設計レビュー結果レポート（`docs/project/DESIGN-REVIEW-REPORT.md`）が作成されている
- 検出された問題がカテゴリ別・優先度別に整理されている
- 各問題に具体的な修正提案が含まれている
- 設計品質の総合評価が記載されている
- ユーザーにレビュー結果が報告されている

## エスカレーション

- 重大な不整合が多数検出された場合：
  - 「重大な不整合が多数検出されました（Error: X件）。設計全体の見直しが必要です。」
  - 「設計レビュー会議を開催し、アーキテクトとチームで問題を議論することを推奨します。」

- データモデルとドメインモデルの乖離が大きい場合：
  - 「データモデルとドメインモデルに大きな乖離があります。」
  - 「ドメインエキスパートを交えて、モデリングワークショップの実施を検討してください。」

- API設計に問題が多い場合：
  - 「API設計に問題が多数あります（X件）。」
  - 「APIガイドライン、RESTful/GraphQLベストプラクティスを参照して設計を見直してください。」

- 非機能要件を満たせない技術選定の場合：
  - 「選定された技術では非機能要件を満たせない可能性があります。」
  - 「技術選定の再評価が必要です。PoC（Proof of Concept）の実施を推奨します。」

- 設計の完全性が低い場合：
  - 「設計が不完全です（カバレッジ XX%）。」
  - 「優先度Highの機能から順に、不足している設計ドキュメントを作成してください。」

## ベストプラクティス

- **段階的レビュー**: すべての設計ドキュメント作成後ではなく、主要ドキュメント（データモデル、API仕様）完成時に部分的にレビュー
- **自動化**: 可能な項目（用語一貫性、リンク切れなど）はスクリプトで自動チェック
- **チームレビュー**: レポートを基にチーム全体でレビュー会議を実施
- **継続的更新**: 設計変更のたびにレビューを再実行し、常に整合性を保つ
- **メトリクス記録**: レビュー結果（Error数、Warning数）を記録し、設計品質の改善を追跡
- **早期検出**: 要件・ドメインレビュー（`/a-006`）完了後、設計着手前にこのレビューの観点を共有
